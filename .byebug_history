exit
n
@now.flash
@now
exit
@now
exit
flash.flash
flash
exit
FlashNow.new(self)
@now
self
exit
flash
exit
flash
flashed?
n
req
flash
flashed?
self
c
match_data[1]
match_data[0]
match_data[2]
match_data
match_data[1]
c
exit
match_data.names.inject({}) { |k, v| k.update(v => v) }
match_data.names
match_data.names.inject({}) { |k, v| k[v] = v; k }
match_data.names.inject({}) { |k, v| k[v] = v}
match_data[:id]
match_data[match_data.names]
match_data.names
match_data
c
exit
route_params
exit
up
n
pattern.match(req.path)[:id]
pattern.match
_[:id]
pattern.match(req.path)
c
exit
pattern.match(req.path)
c
exit
pattern.match
c
exit
pattern.match(req.path)
c
pattern.match(req.path)
req.path
pattern
c
pattern
exit
pattern.match
@pattern
pattern
params
c
exit
name
render(name)
send(name)
name
s
action_name
n
res
req
action_name
c
req
match_data.names
match_data
n
match_data
c
up
n
pattern.match(req.path)
req.path
pattern
exit
req.path
req
c
pattern
n
up
s
req.path
req
exit
true && nil
nil && true
req.request_method.downcase.to_sym == http_method
_ == http_method
req.request_method.downcase.to_sym
req.request_method
pattern =~ req.path
req.path
http_method
pattern
req
s
route.matches?(req)
route
s
@routes
req
erq
c
route.matches?(req)
req
route
s
@routes
c
n
route.matches?(req)
route
s
@routes
exit
route.matches?(req)
@routes
route
s
req
exit
s
exit
n
@routes
req
exit
req
exit
http_method == req.request_method.downcase.to_sym
req
exit
http_method =~ req.request_method
http_method == req.request_method
http_method
req.request_method
!!0
pattern =~ req.path
pattern == req.path
pattern=~req.path
pattern
req.path
